<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>开心博客</title>
  <subtitle>不停止的脚步,不服输的心!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-06-01T06:15:26.687Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>刘欢欢</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅谈图片懒加载</title>
    <link href="http://yoursite.com/2017/06/01/%E6%B5%85%E8%B0%88%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD/"/>
    <id>http://yoursite.com/2017/06/01/浅谈图片懒加载/</id>
    <published>2017-06-01T06:10:25.000Z</published>
    <updated>2017-06-01T06:15:26.687Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>两种图片lazy加载的方式</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// @description 准备为图片预加载使用的插件</span></div><div class="line"><span class="comment">// 使用的图片容器css类名为lazy-load-wrap</span></div><div class="line"><span class="comment">// 图片真实地址为data-lazy-src</span></div><div class="line"><span class="comment">// 当lazy-load-wrap容器进入视口，则开始替换容器内所有需要延迟加载的图片路径，并更改容器的加载状态</span></div><div class="line"><span class="comment">//第一种方法</span></div><div class="line">$.fn.compassLazyLoad=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> _HEIGHT=<span class="built_in">window</span>.innerHeight,</div><div class="line">	_lazyLoadWrap=$(<span class="string">'.lazy-load-wrap'</span>);</div><div class="line"></div><div class="line">	<span class="keyword">var</span> methods=&#123;</div><div class="line">		<span class="attr">setOffsetTop</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			$.each(_lazyLoadWrap,<span class="function"><span class="keyword">function</span>(<span class="params">i,n</span>)</span>&#123;</div><div class="line">				$(n).attr(&#123;</div><div class="line">					<span class="string">'top'</span>:n.offsetTop-_HEIGHT,</div><div class="line">					<span class="string">'status'</span>:<span class="string">'wait'</span></div><div class="line">				&#125;);</div><div class="line">			&#125;)</div><div class="line">		&#125;,</div><div class="line">		<span class="attr">isShow</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">var</span> _scrollTop=$(<span class="built_in">window</span>).scrollTop;</div><div class="line">			<span class="comment">//利用image容器判断是否进入视口，而非image本身</span></div><div class="line">			$.each(_lazyLoadWrap,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">				<span class="keyword">var</span> _that=$(<span class="keyword">this</span>);</div><div class="line">				<span class="keyword">if</span> (_that.attr(<span class="string">'status'</span>)===<span class="string">'done'</span>) &#123;</div><div class="line">					<span class="keyword">return</span>;</div><div class="line">				&#125;;</div><div class="line">				<span class="keyword">if</span> (_that.attr(<span class="string">'top'</span>)&lt;=_scrollTop) &#123;</div><div class="line">					_that.find(<span class="string">'img[data-lazy-src]'</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params">i,n</span>)</span>&#123;</div><div class="line">						n.src=$(n).data(<span class="string">'lazy-src'</span>);</div><div class="line">					&#125;);</div><div class="line">					_that.attr(<span class="string">'status'</span>,<span class="string">'done'</span>);</div><div class="line">				&#125;;</div><div class="line">			&#125;)</div><div class="line">		&#125;,</div><div class="line">		<span class="attr">scroll</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			$(<span class="built_in">window</span>).on(<span class="string">'scroll'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">				methods.isShow();</div><div class="line">			&#125;);</div><div class="line">		&#125;,</div><div class="line">		<span class="attr">init</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			methods.setOffsetTop();</div><div class="line">			methods.isShow();</div><div class="line">			methods.scroll();</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	methods.init();</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//第二种方法</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> exist=(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> timer=<span class="literal">null</span>,</div><div class="line">	temp=[].slice.call($(<span class="string">'.container'</span>));</div><div class="line">	ret=&#123;&#125;;</div><div class="line"></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,len=temp.length<span class="number">-1</span>;i&lt;=len;i++)&#123;</div><div class="line">		ret[i]=temp[i];</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">var</span> isExist=<span class="function"><span class="keyword">function</span>(<span class="params">winTop,winEnd</span>)</span>&#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> ret)&#123;</div><div class="line">			<span class="built_in">console</span>.log(ret);</div><div class="line">			<span class="keyword">var</span> item=ret[i],</div><div class="line">			eleTop=item.offsetTop,</div><div class="line">			eleEnd=eleTop+item.offsetHeight;</div><div class="line"></div><div class="line">			<span class="keyword">if</span>((eleTop&gt;winTop&amp;&amp;eleTop&lt;=winEnd)||(eleEnd&gt;winTop&amp;&amp;eleEnd&lt;=winEnd))&#123;</div><div class="line">				$(item).css(<span class="string">'background'</span>,<span class="string">'none'</span>);</div><div class="line">				<span class="keyword">new</span> Tab($(item).attr(<span class="string">'id'</span>),data).init;</div><div class="line">				<span class="keyword">delete</span> ret[i];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> &#123;</div><div class="line">		<span class="attr">timer</span>:timer,</div><div class="line">		<span class="attr">isExist</span>:isExist</div><div class="line">	&#125;;</div><div class="line">&#125;)($);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//第三种方法</span></div><div class="line">Zepto(<span class="function"><span class="keyword">function</span> (<span class="params">$</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> swiper = <span class="keyword">new</span> Swiper(<span class="string">'.swiper-container'</span>, &#123;</div><div class="line">        <span class="attr">pagination</span>: <span class="string">'.swiper-pagination'</span>,</div><div class="line">        <span class="attr">paginationClickable</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">autoplay</span>: <span class="number">3000</span>,</div><div class="line">        <span class="attr">loop</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">autoplayDisableOnInteraction</span>: <span class="literal">false</span></div><div class="line">    &#125;);</div><div class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">lazyLoad</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> imgs = $(<span class="string">".lazyLoad"</span>);</div><div class="line">        <span class="keyword">var</span> src = <span class="string">''</span>;</div><div class="line">        $.each(imgs, <span class="function"><span class="keyword">function</span> (<span class="params">index, item</span>) </span>&#123;</div><div class="line">            src = $(item).attr(<span class="string">'data-src'</span>);</div><div class="line">            $(item).attr(<span class="string">'src'</span>, src);</div><div class="line">        &#125;);</div><div class="line">    &#125;)();</div><div class="line">&#125;);</div><div class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> lazyLoadTimerId = <span class="literal">null</span>;</div><div class="line">    <span class="comment">/// 智能加载事件</span></div><div class="line">    $(<span class="built_in">window</span>).bind(<span class="string">"scroll"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        clearTimeout(lazyLoadTimerId);</div><div class="line">        lazyLoadTimerId = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="comment">// 延迟加载所有图片</span></div><div class="line">            <span class="keyword">var</span> isHttp = (location.protocol === <span class="string">"http:"</span>);</div><div class="line">            $(<span class="string">"#ym_images img"</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="keyword">var</span> self = $(<span class="keyword">this</span>);</div><div class="line">                <span class="keyword">if</span> (self.filter(<span class="string">":above-the-fold"</span>).length &gt; <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">var</span> originUrl = self.attr(<span class="string">"data-original"</span>);</div><div class="line">                    self.attr(<span class="string">"src"</span>, originUrl);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;, <span class="number">500</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;两种图片lazy加载的方式&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div clas
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>express框架 入门教程</title>
    <link href="http://yoursite.com/2016/08/24/express%E6%A1%86%E6%9E%B6-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2016/08/24/express框架-入门教程/</id>
    <published>2016-08-24T13:17:19.000Z</published>
    <updated>2017-03-24T13:19:07.967Z</updated>
    
    <content type="html"><![CDATA[<p>express框架</p>
<pre><code>产生的原因:
  1.http模块在处理路由这块比较鸡肋
  2.http模块在处理静态资源时比较麻烦
  3.http在获取浏览器的提交过来的参数时很麻烦
  4.express能解决url中有中文时,express能自动解码

基本概念:
express是nodejs发送网络请求的第三方框架,是NodeJS中一个优秀的 web 解决方案

地址:
https://www.npmjs.com/package/express
https://github.com/expressjs/express

安装:
  npm i/install express --save
</code></pre><hr>
<p>express使用步骤</p>
<pre><code>利用express开启web服务器的步骤：
1、在当前项目中使用 npm i/install express --save
2、导入express包
3、利用express对象创建一个application对象 app
4、在app对象上就有一系列方法（get,post）还可以可以分别设置请求路由
5、利用app.listen()监听端口

GET方法获取参数：
  直接从 req.query中就可以获取,非常简单

POST方法获取参数:
  使用一个第三方包 body-parser
</code></pre><hr>
<p>express的路由</p>
<pre><code>/man/xz
/man/ld

/woman/qz
/woman/sw

如何使用:
  1.将某一类路由规则放入到一个js文件中,写好相应的代码,并且暴露出去
    const express = require(&apos;express&apos;);

    let route = express.Router(); //创建一个路由
    路由的处理...

    module.exports = route; //将创建的路由对象暴露出去

  2.在启动服务器的js文件中,导入对应的路由,并且调用app.use方法使用即可
    const route = require(&apos;路由的路径&apos;);

    app.use(&apos;路由规则&apos;,route); //哪些路由规则适用于该路由

开发注意事项:
  设置路由一定要写在入口文件的代码后面一些,最好写在app.listen(xx) 的前一行即可;
</code></pre><hr>
<p>express之next方法</p>
<pre><code>使用方式:(有两种)

  第一种:连写方式,用得比较少
    app.get(&apos;/&apos;,(req,res,next)=&gt;{
      res.write(&apos;1.0 &apos;);
      next();
      },(req,res,next)=&gt;{
      res.write(&apos;2.0 &apos;);
      next();
      },(req,res)=&gt;{
      res.end(&apos;3.0 end&apos;);
      });

  第二种:分开写,用得比较多
    app.get(&apos;/&apos;,(req,res,next)=&gt;{

      res.write(&apos;1.0&apos;);

      //触发下一个同样的路由的回调函数
      next(&apos;route&apos;);
    });

    app.get(&apos;/&apos;,(req,res)=&gt;{

      res.end(&apos;2.0&apos;);
    });

调用的过程分析:
  当浏览器请求 http://127.0.0.1:8888/
  触发第一个回调函数，当在第一个回调函数中手工执行next()的时候
  就会触发第二个回调函数，一直下去直到最后一个回调函数被执行，那么最后
  这个回调函数可以不用写next参数

使用注意:
  触发下一个同样的路由的回调函数,路由必须一致
</code></pre><hr>
<p>express之通配符方法(all)与next方法联合起来做权限验证</p>
<pre><code>使用方式:
  app.all(&apos;路由&apos;,(req,res,next)=&gt;{

    if(登录过){
      next();  //继续往下执行真正的请求
    }else{
      res.end(&quot;请登录&quot;); //提示用户登录
    }
  });

注意点:
  app.all(xxx); 一定要在所有路由的最前面
</code></pre><hr>
<p>express静态资源处理</p>
<pre><code>使用方式:
  app.use(express.static(&apos;静态资源路径&apos;)); 

访问时的注意点:
  如果浏览器要访问statics下面的site.css
  url应该是 http://127.0.0.1:8888/site.css 
  如果是http://127.0.0.1:8888/statics/site.css 反而报错
  如果是statics下面的字母中的静态资源，则一定要在url中加上子目录

注意点:
  设置在路由或是app.use(路由),之前
  要在两个地方写,一个是html里面,还有一个地方是入口的js文件
</code></pre><hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;express框架&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;产生的原因:
  1.http模块在处理路由这块比较鸡肋
  2.http模块在处理静态资源时比较麻烦
  3.http在获取浏览器的提交过来的参数时很麻烦
  4.express能解决url中有中文时,express能自动
    
    </summary>
    
    
      <category term="nodeJS 发送请求" scheme="http://yoursite.com/tags/nodeJS-%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 数据库带你入门</title>
    <link href="http://yoursite.com/2016/07/14/MongoDB-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%A6%E4%BD%A0%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2016/07/14/MongoDB-数据库带你入门/</id>
    <published>2016-07-14T13:28:09.000Z</published>
    <updated>2017-03-24T13:29:48.941Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB 数据库</p>
<pre><code>为了更好的学习 MongoDB 数据库，大家可以参考菜鸟教程上的 MongoDB 数据库教程文档，
链接地址：http://www.runoob.com/mongodb/mongodb-tutorial.html

mongodb数据库官网:https://www.mongodb.com/

下载地址:https://www.mongodb.com/download-center?jmp=nav
选择好对应的版本下载即可
</code></pre><p>MongoDB好处?</p>
<pre><code>理由:

  1.只要会js/json就会mongodb(学习成本低)
  2.mongodb对js的兼容性最好
  3.mongodb存数据就是存JSON
</code></pre><p>安装与配置 MongoDB 数据库环境</p>
<pre><code>详情见视频：

怎么验证安装成功:
  在cmd终端中输入： mongo --version 或是 mongod --version ,能看到版本好,说明安装成功

如果终端中输入 mongo --version 提示找不到命令,一定要看看是不是没有配置mongodb的环境变量,并且配置环境变量之后一定要记得重启cmd
</code></pre><p>window7安装MongoDB存在的问题</p>
<pre><code>建议:升级到window10

解决步骤:
  1.将你的操作系统升级到window7最新版
  2.安装 vc_redist.x64.exe 
  3.如果你的电脑是32位的,再安装32位的mongodb软件 mongodb-win32-i386-3.2.11-signed.msi
</code></pre><p>MongoDB 数据库存储结构</p>
<pre><code>和Excel对比一下即可明白:

Excel                       MongoDB
</code></pre><p>   创建工作簿          创建数据库</p>
<p>   创建一个sheet(工作表单)    创建集合</p>
<p>   确立表头,插入数据        插入文档(确立表头)</p>
<p>  核心思想:</p>
<pre><code>1.分门别类的存储数据

2.mongodb是以集合的概念来区分不同数据的,比如用户集合,商品集合,订单集合等等,不同的数据要放在不同的集合中去统一管理

3.集合里面存储的可以认为是一个数组

4.数组中的每一个对象,可以认为就是JSON对象,在mongodb中我们称之为 文档

5.文档的结构可以随意,但是必须统一,也就是说,同一个集合中,所有的文档一定要遵守相同的数据结构
</code></pre><p>  其他:</p>
<pre><code>集合的作用就是用来隔离数据,分门别类的存储数据
</code></pre><p>操作MongoDB的步骤</p>
<pre><code>1.创建数据库中数据的存储目录
2.启动MongoDB的服务实例
3.创建数据库
4.创建集合
5.创建文档
</code></pre><hr>
<p>MongoDB使用之前必做步骤1–创建数据目录(必须)</p>
<pre><code>我们在安装完成MongoDB后需要创建一个存放数据的目录。请注意，数据目录应该放在根目录下（(如： C:\ 或者 D:\ 等 ),数据目录的命名随意,比如我就命名 mongodb_datas
</code></pre><hr>
<p>MongoDB使用之前必做步骤2–启动服务器(必须)</p>
<pre><code>启动MongoDB服务器的方式一：通过终端指令去启动

  1.首先在终端切换到你的MongoDB的安装目录的bin目录下(当然如果配置了环境变量在哪个目录下都可以了)

  2.在终端执行: mongod.exe --dbpath c:/mongodb_datas ,如果成功启动就表示一切都OK了

  注意点:
    1.32 位版本使用下面的命令启动数据服务：
    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongod --dbpath 数据存储路径 --journal --storageEngine=mmapv1</div></pre></td></tr></table></figure>


    2.执行完上面的命令并成功开启 MongoDB 数据服务实例之后，就把该控制台最小化到一边就可以了，
    千万不要关闭，否则无法连接，如果对数据库的操作结束，可以打开该控制台通过 `Ctrl + C` 关闭。

启动MongoDB服务器的方式二:方式一的延续,把上面的指令做成一个批处理文件.bat

启动MongoDB服务器的方式三:将MongoDB服务器作为Windows服务运行

  请注意，你必须有管理权限才能运行下面的命令。执行以下命令将MongoDB服务器作为Windows服务运行：

  例子:
    mongod.exe --bind_ip 127.0.0.1 --logpath &quot;C:/mongodb_datas/server_log/mongodb.log&quot; --logappend --dbpath &quot;c:/mongodb_datas&quot; --port 27017 --serviceName &quot;MongoDBServer&quot; --serviceDisplayName &quot;MongoDBServerDisplayName&quot; --install

  补充:从Windows服务中卸载 MongoDB服务
    1.先停止要删除的服务(比如MongoDBServer)
    2.以管理员身份运行cmd,在cmd中输入: sc delete 服务名称(比如MongoDBServer)

  注意点:
    1.mongodb.log 这个日志文件一定要先创建好,才能执行指令
    2.必须要以管理员的身份打开cmd窗口,并运行
</code></pre><hr>
<p>如何连接到MongoDB服务器并且操作它？</p>
<p>注意：在进行连接之前请确保你的服务实例是开启状态的（不要关闭刚才开启的数据服务实例）。</p>
<pre><code>可以使用两种方式来连接到MongoDB服务器并且操作它

连接方式1:使用MongoDB自带的MongoDB后台管理 Shell
  在终端中输入 mongo 或是 mongo --host 127.0.0.1 --port 27017

  mongo 命令默认去连接本机上的 MongoDB 服务实例：`127.0.0.1:27017`，可以通过下面的命令
  指定连接的主机名和端口号：
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mongo --host 127.0.0.1 --port 27017</div></pre></td></tr></table></figure>


  如果看到类似于如下的字样说明连接成功：
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">MongoDB shell version v3.4.2</div><div class="line">connecting to: mongodb://127.0.0.1:27017</div><div class="line">MongoDB server version: 3.4.2</div><div class="line">Server has startup warnings:</div><div class="line">2017-01-18T18:49:53.865+0800 I CONTROL  [initandlisten]</div><div class="line">2017-01-18T18:49:53.865+0800 I CONTROL  [initandlisten] ** WARNING: Access control is not enabled for the database.</div><div class="line">2017-01-18T18:49:53.866+0800 I CONTROL  [initandlisten] **          Read and write access to data and configuration is unrestricted.</div><div class="line">2017-01-18T18:49:53.866+0800 I CONTROL  [initandlisten]</div><div class="line">&gt;</div></pre></td></tr></table></figure>

  如果提示 “无法连接主机”，请检查你的 MongoDB 数据服务实例是否开启。

操作方式1:在终端中使用mongodb的指令进行操作

    常见指令:
      见下一个知识点

连接及操作方式2:使用图形化客户端工具:
  robomongo(跨平台) : https://robomongo.org/download
</code></pre><hr>
<p>基本操作命令</p>
<pre><code>可以参考:
  http://www.yiibai.com/mongodb/mongodb_create_collection.html

  http://www.runoob.com/mongodb/mongodb-tutorial.html
</code></pre><ul>
<li>show dbs<ul>
<li>查看当前服务实例上所有的数据库</li>
</ul>
</li>
<li>use 数据库名称<ul>
<li>如果数据库不存在，则创建数据库，否则切换到指定数据库。</li>
</ul>
</li>
<li>db.dropDatabase()<ul>
<li>删除数据库,注意,要在切换的数据库中删除</li>
</ul>
</li>
<li>db<ul>
<li>查看当前所处的数据库</li>
</ul>
</li>
<li>show collections<ul>
<li>查看当前数据库中所有的集合</li>
</ul>
</li>
<li>db.createCollection(“集合名称”)<ul>
<li>创建集合</li>
</ul>
</li>
<li>db.集合名称.drop()<ul>
<li>删除集合</li>
</ul>
</li>
<li>db.集合名称.insert({数据文档})<ul>
<li>插入的每一条文档会自动帮我们生成一个_id字段,它是mongodb自动维护的,不需要我们关心</li>
</ul>
</li>
<li>db.集合名称.find()<ul>
<li>查询指定集合中所有的数据</li>
<li>可以通过 db.集合名称.find().pretty() 美化输出格式</li>
<li>默认是查询所有，可以通过：db.集合名称.find({查询条件}) 按条件查询集合中的数据</li>
<li>模糊查询的条件 {要查询的字段:{$regex: ‘关键字’}}</li>
</ul>
</li>
<li>db.集合名称.update({更新条件}, {要更新的字段})<ul>
<li>更新指定集合数据,注意点,要更新的字段一定要这样写 {$set:{字段的名称:字段的值}},</li>
</ul>
</li>
<li>db.集合名称.update({更新条件}, {要更新的字段},{multi:true})<ul>
<li>更新多条文档,{multi:true}默认是false</li>
</ul>
</li>
<li>db.集合名称.remove({删除条件})<ul>
<li>删除指定集合中的数据</li>
</ul>
</li>
<li>db.集合名称.remove({删除条件},{multi:true})<ul>
<li>删除多条文档,{multi:true}默认是false</li>
</ul>
</li>
<li>exit 退出当前操作</li>
<li>cls 清屏<br>注意点:更新和删除时一般都需要带条件,除非是全部更新与全部删除,不过全部更新与全部删除这样很危险,实际操作过程中很少</li>
</ul>
<p>使用 Node 操作 MongoDB</p>
<p>安装 MongoDB 官方提供的驱动包：</p>
<pre><code>npm install --save mongodb
</code></pre><p>具体操作方式请参考官方文档：<a href="https://www.npmjs.com/package/mongodb" target="_blank" rel="external">https://www.npmjs.com/package/mongodb</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MongoDB 数据库&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;为了更好的学习 MongoDB 数据库，大家可以参考菜鸟教程上的 MongoDB 数据库教程文档，
链接地址：http://www.runoob.com/mongodb/mongodb-tutorial.html

mo
    
    </summary>
    
    
      <category term="数据库,nodeJS" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93-nodeJS/"/>
    
  </entry>
  
  <entry>
    <title>gulp 入门教程</title>
    <link href="http://yoursite.com/2016/04/24/gulp-%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2016/04/24/gulp-入门教程/</id>
    <published>2016-04-24T12:40:48.000Z</published>
    <updated>2017-03-24T12:42:28.239Z</updated>
    
    <content type="html"><![CDATA[<p>Gulp Tutorial</p>
<p>gulp是前端开发过程中一种基于流的代码构建工具，是自动化项目的构建利器；</p>
<p>她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；</p>
<p>使用她，不仅可以很愉快的编写代码，而且大大提高我们的工作效率。</p>
<p>项目构建是指项目上线之前对项目源代码进行一系列处理，使其以最佳的形式运行于线上服务器。</p>
<p>常见处理任包括以下几方面：</p>
<ol>
<li>模块化开发可以实现功能的复用并解决模块间的依赖关系，但带来好处的同时也使得功能代码的碎片化（若干文件）程度增加。</li>
<li>使用less、sass等预处理器，可以降低CSS的维护成本，最终需要将这些预处理器编译成css文件；</li>
<li>对静态资源（css、js、html、images）压缩合并可以提升网页打开速度，提高性能；</li>
</ol>
<p>以上任务完如果完全靠手动来完成是非常耗时耗力的且容易出错，实际开发通常借助构建工具来实现。</p>
<p>所谓构建工具是指通过一系简单配置就可以帮我们实现合并、压缩、校验、预处理等一系列任务的软件工具。</p>
<p>常见的构建工具包括：Grunt、Gulp、F.I.S（百度出品）、webpack等。</p>
<p>Gulp是基于Nodejs开发的一个构建工具，借助gulp插件可以实现不同的构建任务，</p>
<p>其以简洁的配置和卓越的性能成为目前主流的构建工具。</p>
<p>Introduction</p>
<ul>
<li>官方：<a href="http://gulpjs.com/" target="_blank" rel="external">http://gulpjs.com/</a></li>
<li>中文官网：<a href="http://www.gulpjs.com.cn/" target="_blank" rel="external">http://www.gulpjs.com.cn/</a></li>
<li>npm：<a href="https://www.npmjs.com/package/gulp" target="_blank" rel="external">https://www.npmjs.com/package/gulp</a></li>
<li>Github：<a href="https://github.com/gulpjs/gulp" target="_blank" rel="external">https://github.com/gulpjs/gulp</a></li>
<li>Gitbook：<a href="https://wizardforcel.gitbooks.io/gulp-doc/content/2.html" target="_blank" rel="external">https://wizardforcel.gitbooks.io/gulp-doc/content/2.html</a></li>
</ul>
<hr>
<p>Getting Started</p>
<p>官方文档：<a href="https://github.com/gulpjs/gulp/blob/master/docs/getting-started.md" target="_blank" rel="external">https://github.com/gulpjs/gulp/blob/master/docs/getting-started.md</a></p>
<p>一：Install the gulp command</p>
<p>在项目中使用 gulp 首先需要确保全局有 gulp-cli 环境，如果有就不需要执行下面的命令了。</p>
<pre><code># npm install --global gulp-cli
yarn global add gulp-cli
</code></pre><p>二：Install gulp in your devDependencies</p>
<pre><code># npm install --save-dev gulp
yarn add -D gulp
</code></pre><p>三：Create a file called gulpfile.js in your project root with these contents:</p>
<pre><code>var gulp = require(&apos;gulp&apos;);

gulp.task(&apos;default&apos;, function() {
  console.log(&apos;hello gulp&apos;)
})
</code></pre><p>四：Test it out: Run the gulp command in your project directory:</p>
<pre><code>gulp
</code></pre><hr>
<p>API Documentation</p>
<p>官方文档：<a href="https://github.com/gulpjs/gulp/blob/master/docs/API.md" target="_blank" rel="external">https://github.com/gulpjs/gulp/blob/master/docs/API.md</a></p>
<ul>
<li>gulp.task</li>
<li>gulp.src</li>
<li>gulp.dest</li>
<li>gulp.watch</li>
</ul>
<p>gulp.task(name , deps)</p>
<p>作用：定义各种不同的任务</p>
<ul>
<li>gulp.task(name, fn)</li>
<li>gulp.task(name, deps, fn)</li>
<li>gulp.task(name, fn(cb))</li>
<li>gulp.task(name, deps, fn(cb))</li>
</ul>
<p>一：普通任务</p>
<pre><code>gulp.task(&apos;a&apos;, function () {
  console.log(&apos;1 aaa&apos;)
})

gulp.task(&apos;b&apos;, function () {
  console.log(&apos;2 bbb&apos;)
})
</code></pre><p>二：任务之间的依赖</p>
<pre><code>gulp.task(&apos;a&apos;, function (cb) {
  setTimeout(function () {
    console.log(&apos;1 aaa&apos;)
    cb()
  }, 1000)
})

// b 任务依赖的 a 任务中的回调函数如果不调用，b 任务是不会执行的
gulp.task(&apos;b&apos;, [&apos;a&apos;], function () {
  console.log(&apos;2 bbb&apos;)
})
</code></pre><p>三：gulp 流控制</p>
<pre><code>gulp.task(&apos;a&apos;, function () {
  // 当任务中是一个 gulp 流的时候则需要通过 return 来保证依赖中的执行顺序
  return gulp.src()
    .pipe()
    // ...
})

gulp.task(&apos;b&apos;, [&apos;a&apos;], function () {
  // doSomething
})
</code></pre><p>gulp.src(globs[, options])</p>
<p>gulp教程之gulp中文API：<a href="http://www.ydcss.com/archives/424" target="_blank" rel="external">http://www.ydcss.com/archives/424</a></p>
<p>作用：根据路径（字符串或数组）读取需要构建的资源</p>
<p>globs</p>
<p>需要处理的源文件匹配符路径。</p>
<p>类型(必填)：String or StringArray，通配符路径匹配示例：</p>
<ul>
<li>src/a.js 指定具体文件；</li>
<li><ul>
<li>匹配所有文件    例：src/*.js (包含src下的所有js文件)；</li>
</ul>
</li>
<li><strong> 匹配0个或多个子文件夹    例：src/</strong>/*.js (包含src的0个或多个子文件夹下的js文件)；</li>
<li>{} 匹配多个属性    例：src/{a,b}.js (包含a.js和b.js文件)  src/*.{jpg,png,gif}(src下的所有jpg/png/gif文件)；</li>
<li>! 排除文件    例：!src/a.js (不包含src下的a.js文件)；</li>
</ul>
<p>options.base</p>
<p>options.base：类型：String  设置输出路径以某个路径的某个组成部分为基础向后拼接，具体看下面示例：</p>
<pre><code>gulp.src(&apos;client/js/**/*.js&apos;) 
  .pipe(minify())
  .pipe(gulp.dest(&apos;build&apos;))  // Writes &apos;build/somedir/somefile.js&apos;

gulp.src(&apos;client/js/**/*.js&apos;, { base: &apos;client&apos; })
  .pipe(minify())
  .pipe(gulp.dest(&apos;build&apos;))  // Writes &apos;build/js/somedir/somefile.js&apos;
</code></pre><p>gulp.dest(path[, options])</p>
<p>作用：构建任务完成后资源存放的路径</p>
<p>gulp.watch(glob[, opts], tasks)</p>
<p>监视指定资源的改动，然后可以调用响应的任务处理</p>
<p>gulp.watch(glob [, opts, cb])</p>
<hr>
<p>常用插件</p>
<p>  插件名称                        作用<br>  del                         删除文件或文件夹<br>  gulp-less                   编译LESS文件<br>  gulp-rname                  重命名文件<br>  gulp-imagemin               图片压缩<br>  gulp-uglify                 压缩Javascript<br>  gulp-concat                 合并 js 文件<br>  gulp-concat-css             合并 css 文件<br>  gulp-cssnano                压缩 css<br>  gulp-htmlmin                压缩HTML<br>  gulp-nunjucks               模板引擎<br>  gulp-rev                    添加版本号<br>  gulp-rev-collector          内容替换<br>  gulp-useref                 gulp-if<br>  gulp-load-plugins           依赖自动加载<br>  gulp-useref                 自动合并打包处理<br>  gulp-wrap                   包装内容<br>  gulp-angular-templatecache  AngularJS 模板缓存<br>  browser-sync                和 gulp 配合使用实现文件改变执行某个任务后自动刷新<br>  yargs                       获取命令行参数<br>  gulp-if                     根据判断条件执行某个插件<br>  http-proxy-middleware       http 代理插件                   </p>
<p>gulp 实战之：高级写页面</p>
<p>实现 HTML 模板功能，例如公共 HTML 头部和底部，提供可维护性，</p>
<p>以及实现 HTML 自动压缩，css 压缩，js 压缩，或者合并。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Gulp Tutorial&lt;/p&gt;
&lt;p&gt;gulp是前端开发过程中一种基于流的代码构建工具，是自动化项目的构建利器；&lt;/p&gt;
&lt;p&gt;她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；&lt;/p&gt;
&lt;p&gt;使用她，不仅可以很愉快的编写代码，而且大
    
    </summary>
    
    
      <category term="gulp" scheme="http://yoursite.com/tags/gulp/"/>
    
  </entry>
  
  <entry>
    <title>nodeJS的核心模块</title>
    <link href="http://yoursite.com/2016/04/13/nodeJS%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2016/04/13/nodeJS的核心模块/</id>
    <published>2016-04-13T12:15:40.000Z</published>
    <updated>2017-03-13T12:18:38.711Z</updated>
    
    <content type="html"><![CDATA[<p>Node核心模块之HTTP模块</p>
<pre><code>作用:
  处理客户端的网络请求

代码步骤:
  1.导入 HTTP 核心模块
  2.监听客户端的请求
  3.处理客户端的请求
  4.开启服务器
</code></pre><hr>
<p>Node核心模块之URL模块</p>
<pre><code>作用:
  处理客户端请求过来的URL

代码步骤:
  1.导入 URL 核心模块
  2.导入 HTTP 核心模块
  3.监听客户端的请求
  在这中间处理客户端请求过来的URL
  4.处理客户端的请求
  5.开启服务器   
</code></pre><hr>
<p>NodeJS核心模块之Query Strings模块</p>
<pre><code>作用:处理客户端通过`get/post`请求传递过来的参数

使用关键点:
  1.需要导入 &apos;querystring&apos; 这个核心模块
  2.`get`请求时 querystring 一般是配合 url 核心模块一起使用的
  3.`get/post`请求最终都需要调用 querystring.parse方法,
  将请求传递过来的键值对字符串转成js对象,方便操作

注意:
  get/post的请求方式是不一样的,客户端传递过来时,参数放在
  的地方是不一样的,所以服务器端处理方式也不太一样
</code></pre><hr>
<p>NodeJS核心模块之File System模块</p>
<pre><code>前提:以后的所有静态资源(html,css,js,图片等)都是放在服务端
的,如果浏览器需要这些html,css,js,图片等资源,则需要先将其读
取到node.exe的内容中,然后再返回给浏览器

作用:
  在服务端来操作文件,可能是需要将浏览器上传的图片保存到服
  务器,也可能是需要将服务器的资源读取之后返回给浏览器

代码步骤:
  1.导入 fs 核心模块
  2.使用相应的方法来写入文件、读取文件等操作

注意点:
  目录 fs它是不会自动帮我们创建的需要我们自己手工创建
  文件如果不存在,调用writeFile与appendFile方法会自动帮
  我们创建
</code></pre><hr>
<p>NodeJS核心模块之Path模块</p>
<pre><code>作用:操作文件的路径,为文件操作服务

常用的几个函数:
  path.join(第一个路径,第二个路径) : 拼接路径
</code></pre><hr>
<p>NodeJS核心模块之Global模块</p>
<pre><code>作用:全局共享的,不需要导入模块即可以使用

常用的属性:
  __dirname : 文件所在的文件夹路径
  __filename : 文件所在的路径
  require() : 导入需要的模块
  module : 自定义模块时用到
  exports : 自定义模块时用到
</code></pre><hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Node核心模块之HTTP模块&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;作用:
  处理客户端的网络请求

代码步骤:
  1.导入 HTTP 核心模块
  2.监听客户端的请求
  3.处理客户端的请求
  4.开启服务器
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;Node核心模块
    
    </summary>
    
    
      <category term="nodeJS" scheme="http://yoursite.com/tags/nodeJS/"/>
    
  </entry>
  
  <entry>
    <title>webpack构建项目</title>
    <link href="http://yoursite.com/2016/03/24/webpack%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/"/>
    <id>http://yoursite.com/2016/03/24/webpack构建项目/</id>
    <published>2016-03-24T12:06:15.000Z</published>
    <updated>2017-03-24T12:08:45.917Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><p>  概念:<br>    webpack就是一个资源打包工具,它可以将css,js,image,.vue等等文件当做一个模块来进行打包处理,最终将这些资源输出到一个统一的.js文件中,将来在系统中只需要请求这个打包好的.js文件即可完成所有的功能！</p>
<p>  为什么要选择webpack<br>    1.vuejs官方脚手架工具中就使用了webpack模版<br>    2.对所有的资源会做压缩等优化<br>    3.它在开发过程中提供了一整套完整的功能,能够使我们开发过程变得高效</p>
<hr>
<h1 id="webpack的使用"><a href="#webpack的使用" class="headerlink" title="webpack的使用"></a>webpack的使用</h1><p>  使用途径:</p>
<pre><code>官方文档

1.x版本,项目中使用的是1.13.3这个版本
  http://webpack.github.io/docs/

2.x版本
  https://webpack.js.org/

https://github.com/webpack/webpack
</code></pre><p>  学习文章:<br>    <a href="http://www.w2bc.com/Article/50764" target="_blank" rel="external">http://www.w2bc.com/Article/50764</a><br>    <a href="http://www.jianshu.com/p/42e11515c10f" target="_blank" rel="external">http://www.jianshu.com/p/42e11515c10f</a></p>
<p>  使用步骤:<br>    1.安装webpack这个全局包 npm install webpack -g<br>    2.在cmd控制面板中调用webpack的指令给定两个参数 要打包的文件 要输出的文件路径 例如:webpack main.js build.js</p>
<hr>
<h1 id="webpack的基本概念"><a href="#webpack的基本概念" class="headerlink" title="webpack的基本概念"></a>webpack的基本概念</h1><p>  什么是webpack?<br>    Webpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过 loader 的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、 AMD 模块、 ES6 模块、CSS、图片、 JSON、Coffeescript、 LESS 等。</p>
<p>  Github地址:<br>    <a href="https://github.com/webpack/webpack" target="_blank" rel="external">https://github.com/webpack/webpack</a></p>
<p>  官网:<br>    <a href="https://webpack.js.org/" target="_blank" rel="external">https://webpack.js.org/</a></p>
<p>  能做什么?<br>    打包及优化我们的代码,还能做到按需加载</p>
<p>  相比于其它构建工具/打包工具,比如gulp好在哪里?<br>    <a href="http://webpackdoc.com/what-is-webpack.html" target="_blank" rel="external">http://webpackdoc.com/what-is-webpack.html</a></p>
<pre><code>1.代码拆分
2.Loader
3.智能解析
4.插件系统
5.快速运行
</code></pre><hr>
<h1 id="webpack的安装"><a href="#webpack的安装" class="headerlink" title="webpack的安装"></a>webpack的安装</h1><p>  npm install webpack -g</p>
<hr>
<h1 id="webpack中的Loader"><a href="#webpack中的Loader" class="headerlink" title="webpack中的Loader"></a>webpack中的Loader</h1><p>  作用:<br>    Webpack 本身只能处理 JavaScript 模块，如果要处理其他类型的文件，就需要使用 loader 进行转换。</p>
<hr>
<h1 id="webpack中的插件"><a href="#webpack中的插件" class="headerlink" title="webpack中的插件"></a>webpack中的插件</h1><p>  作用:<br>    插件可以完成更多 loader 不能完成的功能。</p>
<hr>
<h1 id="webpack中webpack-dev-server"><a href="#webpack中webpack-dev-server" class="headerlink" title="webpack中webpack-dev-server"></a>webpack中webpack-dev-server</h1><p>  作用:<br>    可以简化我们的webpack打包的操作,当我们的源代码更改后<br>    会自动打包,并且刷新页面,有点类似于nodemon</p>
<hr>
<h1 id="npm-amp-cmd控制面板-amp-cmd的指令"><a href="#npm-amp-cmd控制面板-amp-cmd的指令" class="headerlink" title="npm? &amp; cmd控制面板 &amp;cmd的指令"></a>npm? &amp; cmd控制面板 &amp;cmd的指令</h1><p>  npm:<br>    1.npmjs.com存储了很多nodejs第三方的功能包<br>    2.利用npm这个工具,可以将nodejs第三方包通过相关指令进行安装,例如 npm install webpack -g<br>    3.只要安装好了node.exe这个软件,就自动安装好了npm这个包</p>
<p>  如何查看npm<br>    在终端中输入 npm -v</p>
<hr>
<h1 id="webpack案例"><a href="#webpack案例" class="headerlink" title="webpack案例"></a>webpack案例</h1><p>  意义:<br>    明白模块化开发的思想(需要谁就导入谁)</p>
<p>  写法:<br>    var 模块 = require(‘xxx/xxx.js’);<br>    路径可以是相对路径也可以是绝对路径</p>
<p>  注意:<br>    我们通过require导入的模块,其实就是对应js文件中通过module.exports导出的东西</p>
<p>  步骤:<br>    1.先写好js代码<br>    2.利用webpack打包成浏览器可以解析的js代码,主要对main.js进行打包,这样main.js依赖的模块也会一并打包<br>    3.在网页中导入上一步中打包并且生成好的build.js,在浏览器中运行</p>
<p>  webpack打包指令:<br>    webpack 要打包的文件 输出的文件</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;webpack&quot;&gt;&lt;a href=&quot;#webpack&quot; class=&quot;headerlink&quot; title=&quot;webpack&quot;&gt;&lt;/a&gt;webpack&lt;/h1&gt;&lt;p&gt;  概念:&lt;br&gt;    webpack就是一个资源打包工具,它可以将css,js,image,.v
    
    </summary>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>关于NodeJS</title>
    <link href="http://yoursite.com/2016/03/13/%E5%85%B3%E4%BA%8ENodeJS/"/>
    <id>http://yoursite.com/2016/03/13/关于NodeJS/</id>
    <published>2016-03-13T11:52:26.000Z</published>
    <updated>2017-03-24T13:22:53.452Z</updated>
    
    <content type="html"><![CDATA[<p>学习资源推荐</p>
<pre><code>网站:国内NodeJS开发者社区：https://cnodejs.org/

书籍:《深入浅出Node.js》：作者：阿里巴巴.朴灵

阿里开源论坛:http://code.taobao.org/

360下面的:https://75team.com/

http://stackoverflow.com/ 全世界最牛的程序员问
答网站
</code></pre><hr>
<p>NodeJS 服务器搭建(NodeJS的软件安装)</p>
<pre><code>安装步骤:
  见 其它资料 &gt; node.msi安装Node截图

NodeJS服务器的搭建,就类似于我们安装Apache服务器

如何判断有没有安装成功:
  在cmd终端中输入 node -v 看有没有提示,如果有提示就说明
  安装成功了,如果没有,还需要做下一步

mac:https://brew.sh/index_zh-cn.html

使用nvm安装多个node版本并且进行切换:
  http://www.jianshu.com/p/07c3456e875a
</code></pre><hr>
<p>系统环境变量的配置</p>
<pre><code>目的:
  为了能在终端的任何一个目录下 启动 Node.exe,来执行我们的
  NodeJS的代码

环境变量有些类似于我们的桌面快捷方式

配置步骤:
  可以参考 其它资料 &gt; 环境变量设置(以QQ为例) 来配置
  Node.exe的环境变量,方便在终端的任何目录下启动Node.exe
  (REPL执行环境),来执行我们的NodeJS代码
</code></pre><hr>
<p>REPL执行环境的解释</p>
<pre><code>它就是我们NodeJS代码的运行环境



前提:
  我们的NodeJS的代码不是运行在浏览器中的,那他运行在哪里呢?

基本概念:
  1.REPL就是Node.exe 启动起来之后的运行环境

  2.REPL 可以理解成类似于`启动起来的`Apache服务器

  3.Node.exe(REPL)环境启动之后,就会执行放入它里面的
  NodeJS代码了,类似于启动Apache服务器之后就可以运行放入它
  里面的php代码了

  4.js代码放入到node.exe中就可以执行了

运行起来的 node.exe == REPL执行环境
</code></pre><hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习资源推荐&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;网站:国内NodeJS开发者社区：https://cnodejs.org/

书籍:《深入浅出Node.js》：作者：阿里巴巴.朴灵

阿里开源论坛:http://code.taobao.org/

360下面的:https://
    
    </summary>
    
    
      <category term="nodeJS" scheme="http://yoursite.com/tags/nodeJS/"/>
    
  </entry>
  
  <entry>
    <title>package.json 到底做了什么?</title>
    <link href="http://yoursite.com/2016/02/24/package-json-%E5%88%B0%E5%BA%95%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>http://yoursite.com/2016/02/24/package-json-到底做了什么/</id>
    <published>2016-02-24T13:02:26.000Z</published>
    <updated>2017-03-24T13:07:03.653Z</updated>
    
    <content type="html"><![CDATA[<p>package.json</p>
<pre><code>作用:
  1.每个Node项目中及第三方包中都必须的
  2.它描述着Node项目或是第三方包的一些信息
  3.透过这些信息可以知道该Node项目或是第三方包运行起来要依赖于哪些第
  三方包
  4.还可以在里面写一些终端执行脚本,在package.json的scripts中进行定义

使用步骤:
  1.打开终端cmd或是powershell
  2.切换到该Node项目的根目录下面去
  3.执行 npm init -y 或是 npm init 生成package.json
  4.在开发过程中安装第三方包的时候这样写 npm install --save 或是 
  npm install --save-dev

注意:
  1.使用 npm init -y 的时候一定要注意,项目名称不能是中文,否则报错
  2.npm init 生成package.json的时候,按照要求一步一步来
  3.如果是开发阶段需要的第三方包,使用 npm install --save-dev
  4.如果是运行阶段需要的第三方包,使用 npm install --save

package.json一些重要属性说明:
  name : 项目或是第三方包的名称,也是其它项目导入时require()中的名称
  description : 这个项目或是第三方包功能的描述
  main : 项目或是第三方包的入口文件
  license : 授权方式,一般写MIT
  keywords : 发布到npmjs中之后,其它开发者搜索我们这个第三方包的关键
  字
  scripts : 以后在终端执行的脚本
  devDependencies : 开发阶段依赖的包
  dependencies : 运行阶段依赖的包
  author : 作者
  version : 版本号
</code></pre><hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;package.json&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;作用:
  1.每个Node项目中及第三方包中都必须的
  2.它描述着Node项目或是第三方包的一些信息
  3.透过这些信息可以知道该Node项目或是第三方包运行起来要依赖于哪些第
  三方包
  4.还可以在里面
    
    </summary>
    
    
      <category term="npm" scheme="http://yoursite.com/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>npm 使用方法2</title>
    <link href="http://yoursite.com/2016/01/29/npm-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%952/"/>
    <id>http://yoursite.com/2016/01/29/npm-使用方法2/</id>
    <published>2016-01-29T13:08:41.000Z</published>
    <updated>2017-03-24T13:09:59.565Z</updated>
    
    <content type="html"><![CDATA[<p>npm的介绍</p>
<pre><code>npm是用来管理nodejs第三方包的一个工具,利用它可以
  1.安装 本地包/全局包 
  2.将自己写的包发布到npmjs上面去,供全世界的开发者使用

npm在安装好node之后,就会自动安装到node的安装目录中,一般是安装在node根目录的node_modules的子文件夹下,比如我的npm就安装在 C:\Program Files\nodejs\node_modules

如何测试npm是否安装成功,在终端中输入 npm -v 如果能出现版本号就表示安装成功
</code></pre><p>npm操作之从npmjs.com中安装/下载包</p>
<pre><code>安装包/下载包分两种

  本地安装:用在当前项目中
    命令:npm install 本地包的名称

  全局安装:以后在终端中使用
    命令:npm install -g 全局包的名称

    其它命令:
    1.查看全局包安装路径:npm root -g

    2.更改全部安装包安装路径:npm config set fix &quot;全局包的路径&quot;
      当我们用 `npm install - g 全局包的名称` 这个指令的时候,有的时候全局包可能会安装在 C:\Users\你的电脑名称\AppData\Roaming\npm\node_modules下面,这个时候如果你要更改全局包的安装路径,可以使用
</code></pre><p>发布自己的框架到npm上面去【了解】</p>
<pre><code>步骤:
  1.先创建一个以包命令的文件夹(&quot;注意：该包名必须是npmjs上面没有的,否则后面上传不上去哈&quot;)

  2.写好你自己要发布的包里面的代码(书写规范建议)
    2.1 个人建议将那些零散的代码放在一个 lib 文件夹下
    2.2 在包的更目录下建立一个 index.js 入口js文件
    2.3 包名称必须小写,这个是npmjs.com的规定

  3.在包的根目录下设置好 package.json 里面的内容
    创建package.json有两种方式
      方式1：npm init -y (会生成好package.json,并且会在package.json中生成些默认的键值对)

      方式2：npm init (也会生成package.json,但是会提示你生成哪些需要的键值对,一般要生成的键值对有:name、version、main、description、keyword等等)

  4.可以在包的根目录下创建一个README.md写上你这个框架的介绍,以及如何使用

  5.开始上传

    注意事项:在要发布包的文件夹下，执行相关指令（打开面板的执行路径是和package.json在同一级就行）

    步骤:
      5.1 先登录到npmjs网站上面去: npm adduser
        会提示你输入在npmjs网站上面的用户名和密码的,在这个过程中当你输入了正确的用户名和密码之后,还可能提示你的用户名和密码错误,这个时候就需要查看下当前的镜像是否是淘宝

      5.2 登录成功之后,这个时候使用 npm publish 发布到npmjs.com上面去

  6.撤销(可选)
    步骤:
      6.1 先登录

      6.2 撤销 npm unpublish 包名称@版本号

  注意:
    1.登录之前要看下我们的镜像是否是npmjs.com
    2.如果改了源代码,要再发布,得更改下版本号,版本号只能递增
</code></pre><hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;npm的介绍&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm是用来管理nodejs第三方包的一个工具,利用它可以
  1.安装 本地包/全局包 
  2.将自己写的包发布到npmjs上面去,供全世界的开发者使用

npm在安装好node之后,就会自动安装到node的安装目录中,一般是
    
    </summary>
    
    
      <category term="npm" scheme="http://yoursite.com/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>npm 使用方法</title>
    <link href="http://yoursite.com/2016/01/24/npm-%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/01/24/npm-使用方法/</id>
    <published>2016-01-24T12:57:32.000Z</published>
    <updated>2017-03-24T12:58:52.004Z</updated>
    
    <content type="html"><![CDATA[<p>npm</p>
<pre><code>概念:
  用来管理nodejs第三方包的一个工具

注意:
  一般情况下,安装了node之后,都会安装npm,npm所在的位置一般在
  C:\Program Files\nodejs\node_modules

  如果在终端中输入 npm -v 有反映就表示成功了
</code></pre><hr>
<p>npm操作之从npmjs.com中安装/下载包</p>
<pre><code>npm在安装好nodejs之后,就会在nodejs安装目录的node_moules目录下自动帮我们安装好了npm这个包

安装包/下载包分两种

  本地安装:用在当前项目中
  命令:npm install 包的名称

  全局安装:以后在终端中使用
  命令:npm install -g 包名称
</code></pre><hr>
<p>nrm</p>
<pre><code>相当于镜像

npm install [-g] 包名称   默认情况下去npmjs.com下载包

nrm ls 可以查看有哪些镜像,并且当前使用的是哪个镜像

cnpm 的使用
  步骤1:安装cnpm的全局包 npm install -g cnpm

  步骤2:
</code></pre><hr>
<p>cnpm 与 npm 的区别</p>
<pre><code>相同点:都是管理nodejs第三方包的网站

不同点:
  npm 是正宗
  cnpm 是淘宝团队开发的

https://npm.taobao.org 这个网站的所有内容来自哪里npmjs.com

  安装包的方式不一样
    npm : npm install [-g] 包名称
    cnpm : cnpm install [-g] 包名称

  注意点:
    npmjs.com 既可以从他上面 下载包,也可以往它上面传我们自己写的包
    https://npm.taobao.org  是一个只读的,只能下载,不能上传

  应用场景:
    一般情况下 使用 npmjs.com
    特殊情况下 使用 https://npm.taobao.org 
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;npm&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;概念:
  用来管理nodejs第三方包的一个工具

注意:
  一般情况下,安装了node之后,都会安装npm,npm所在的位置一般在
  C:\Program Files\nodejs\node_modules

  如果在终端中输
    
    </summary>
    
    
      <category term="npm" scheme="http://yoursite.com/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>ES6 语法的基本使用</title>
    <link href="http://yoursite.com/2015/09/24/ES6-%E8%AF%AD%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2015/09/24/ES6-语法的基本使用/</id>
    <published>2015-09-24T12:49:25.000Z</published>
    <updated>2017-03-24T12:52:00.908Z</updated>
    
    <content type="html"><![CDATA[<p>ES6语法</p>
<pre><code>规范/标准/协议

一种是设计和规范语言(javascript),浏览器厂商遵守

开发者也要遵守

ES6全称是 ECMAScript 6 (2015) ECMAScript 6也叫 ECMAScript 2015（官方叫法）

ECMA:欧洲计算机制造协会

一流的公司做标准 华为 android
二流的公司做设计 javascript
三流的公司做产品 

ECMAScript是JavaScript语言的标准 ，JavaScript是ES的实现

特点：
  1.ES6向下兼容ES5.1，只不过增加和改善了一些新东西
  2.ES6是JS下一代语言标准，在2015-6月正式发布(http://www.ecma-international.org/ecma-262/6.0/)

意义:
  让JavaScript语言能够开发大型复杂的应用程序，意味着js将成为企业级开发语言(java,php,python)
</code></pre><hr>
<p>当前浏览器对于ES6的支持情况</p>
<pre><code>ES6作为新一代标准，各大浏览器支持是需要一段时间的
查看各大浏览器对于ES6的支持情况 (http://kangax.github.io/compat-table/es6/)

注意点：
  1.Node.js由于采用的是Chrome 浏览器的V8引擎来解析js代码的，所以对于ES6的支持非常好
  2.Node.js开发运行在服务器端的，所以不需要考虑ES6的兼容问题，可以放心用
</code></pre><hr>
<p>ES6的基本使用</p>
<pre><code>要想使用ES6的语法，必须开启严格模式 ，让js在更加严格的环境中运行

开启严格模式的目的：
  1.消除Javascript语法的一些不严谨之处，减少程序开发中出错的几率
  2.在Node.js中某些ES6的语法只有在严格模式下才支持

如何开启严格模式：
  1.在js文件的第一行输入 &quot;use strict&quot;
  2.注意：&quot;use strict&quot; 只能放在第一行，否则无效
</code></pre><hr>
<p>ES6之let</p>
<pre><code>let是es6标准中的一个用来申明变量的关键字,用法类似于var

注意点:
  1.使用let申明的变量只在let关键字所在的代码块有效
  2.不存在变量提升：遵循先申明后使用的原则，否则报错
  3.块级作用域内let申明的变量不受外部影响，可以定义外层作用域的同名变量
  4.不允许在相同作用域内重复申明同一个名称的变量

开发建议:
  在`Node.js`开发中，我们通常使用严格模式加let 来替换原来的var申明变量
</code></pre><hr>
<p>ES6之const</p>
<pre><code>用来申明一个常量

注意点:
  1.一旦申明，常量的值就不能改变
  2.常量具有块级作用域
  3.不要在块中申明常量 
  4.没有变量提升，先声明后使用
  5.不可以重复申明同名的常量
  6.Const定义的常量，一定要赋初始值，否则报错

特点:
  Const关键字声明的常量，表示此常量的内存地址不能改变，但可以改变其内部属性的值   举例说明

开发建议:
  在node.js编程中，所有接收require()获得的对象都先使用const修饰,如果不能满足需求再改,目的是表明,我只是想用你这个模块中的方法或是属性,而不是想改变你。
</code></pre><hr>
<p>ES6之字符串扩展方法</p>
<pre><code>传统JavaScript只有indexOf()方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法：

  1.includes() ：返回布尔值，表示是否找到了参数字符串
  2.startsWith() ：返回布尔值，表示是否以参数字符串开头
  3.endsWith() ：返回布尔值，表示是否以参数字符串结尾

repeat方法返回一个新字符串，表示将原字符串重复n次



模版字符串(以后很常用)

  作用：动态的拼接我们的字符串

  1.使用两个反引号  ` ` 按数字1键左边的键 来表示一个模板字符串
  2.在模版字符串中可以嵌入变量，函数，对象
  3.如果在模板字符串中要使用特殊字符(比如反引号) 则要使用 \ 转意

  好处：
    1.省去+
    2.美化格式
    3.里面的数据还可以动态化 ${常量/变量的名称}
</code></pre><hr>
<p>ES6之箭头函数</p>
<pre><code>格式
  (形参1,形参2,...)  =&gt; {方法体}

推演:
  1.本质上，箭头函数是通过 function 函数推演过来的
  2.箭头函数其实就是function的简化写法

  举例说明
  function(x,y){} 演变成箭头函数 (x,y)=&gt;{}

特点:
  1.如果参数只有一个，可以将()省略  // arr.map(c=&gt;c+1);

  2.如果没有参数，则一定能要写上()  // ()=&gt; console.log(&apos;a&apos;)

  3.如果多于一个参数，每个参数之间用逗号分隔  (x, y) =&gt; { ... }

  4.如果方法体只有一句代码，可以省略{} 和分号

  5.如果方法体多于一句代码，则不能省略{} ,每句代码使用

开发建议:
  尽量使用 (形参1,形参2,...)  =&gt; {方法体};
  用多了自然就懂了,不需要担心
</code></pre><hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ES6语法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;规范/标准/协议

一种是设计和规范语言(javascript),浏览器厂商遵守

开发者也要遵守

ES6全称是 ECMAScript 6 (2015) ECMAScript 6也叫 ECMAScript 2015（官方叫法）


    
    </summary>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>post/get请求的区别</title>
    <link href="http://yoursite.com/2015/05/13/post-get%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2015/05/13/post-get请求的区别/</id>
    <published>2015-05-13T12:10:56.000Z</published>
    <updated>2017-03-13T12:12:39.177Z</updated>
    
    <content type="html"><![CDATA[<p>GET/POST的知识总结</p>
<pre><code>相同点:
  1.发送网络请求
  2.可以给服务器传递参数

不同点:
  传参的方式不一样
    GET: 
      http://127.0.0.1/login?username=zhangsan&amp;password=123
      请求体中是没有内容的

    POST:
      http://127.0.0.1/login
      参数放在请求体 username=zhangsan&amp;password=123

  传参的长度
    GET:有限制 256KB
    POST:理论上没限制,但是每个服务器规定不一样 Apache 5M

  缓存方式
    GET:有缓存
    POST:没有,因为POST主要用来给服务器提交数据,而这些数据是动态变化的

  安全性方面
    GET:很不安全
    POST:相对安全

应用场景:
  1.GET 当单纯向服务器获取数据的时候,一般用GET,因为有缓存,效率高
  2.POST 一般用在提交数据给服务器
  3.根据公司后台人员给的API文档来
</code></pre><hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GET/POST的知识总结&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;相同点:
  1.发送网络请求
  2.可以给服务器传递参数

不同点:
  传参的方式不一样
    GET: 
      http://127.0.0.1/login?username=zhangsan&amp;amp
    
    </summary>
    
    
      <category term="post/get" scheme="http://yoursite.com/tags/post-get/"/>
    
  </entry>
  
  <entry>
    <title>angular 从入门到精通</title>
    <link href="http://yoursite.com/2015/04/24/angular-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A/"/>
    <id>http://yoursite.com/2015/04/24/angular-从入门到精通/</id>
    <published>2015-04-24T12:24:36.000Z</published>
    <updated>2017-03-24T12:27:36.772Z</updated>
    
    <content type="html"><![CDATA[<p>AngularJS 表达式</p>
<ul>
<li>AngularJS 表达式写在双大括号内：</li>
<li>AngularJS 表达式把数据绑定到 HTML，与 ng-bind 指令基本一致</li>
<li>AngularJS 将在表达式书写的位置”输出”数据<ul>
<li>数字</li>
<li>字符串</li>
<li>对象</li>
<li>数组</li>
</ul>
</li>
<li>AngularJS 表达式 很像 JavaScript 表达式：它们可以包含字符串、操作符和变量<ul>
<li>与 JavaScript 表达式不同，AngularJS 表达式可以写在 HTML 中</li>
<li>与 JavaScript 表达式不同，AngularJS 表达式不支持条件判断，循环及异常</li>
<li>与 JavaScript 表达式不同，AngularJS 表达式支持过滤器</li>
</ul>
</li>
</ul>
<p>AngularJS 指令</p>
<p>AngularJS 指令是以 ng- 作为前缀的 HTML 属性，</p>
<p>AngularJS 通过内置的指令来为应用添加功能，</p>
<p>AngularJS 同时允许你自定义指令，从而构建更加超动感的 HTML。</p>
<p>HTML5 允许扩展的（自制的）属性，以 data- 开头。</p>
<p>AngularJS 属性以 ng- 开头，但是也可以使用 data-ng- 来让网页对 HTML5 有效。</p>
<ul>
<li>ng-app<ul>
<li>入口标识</li>
</ul>
</li>
<li>ng-init<ul>
<li>可以在模型仓库中初始化数据</li>
</ul>
</li>
<li>ng-model<ul>
<li>可以和表单控件的 value 进行双向绑定</li>
</ul>
</li>
<li>ng-bind<ul>
<li>和表达式一样，可以解决表达式闪烁的问题</li>
</ul>
</li>
<li>ng-click</li>
<li>ng-repeat</li>
</ul>
<p>使用总结</p>
<ul>
<li>AngularJS 最大程度上减少了页面上的 DOM 操作</li>
<li>让开发人员更专注于业务操作</li>
<li>通过简洁的指令结合页面结构与逻辑数据</li>
<li>通过自定义指令实现组件化编程</li>
<li>代码结构更合理</li>
<li>维护成本更低</li>
<li>AngularJS 解放了传统 JavaScript 中频繁的 DOM 操作</li>
</ul>
<p>模块</p>
<p>创建模块：</p>
<pre><code>angular.module(&apos;模块名称&apos;, [])
</code></pre><p>启动模块：</p>
<pre><code>// 指令方式启动
ng-app=&quot;模块名&quot;

// 代码方式启动
angular.bootstrap(document, [&apos;模块名&apos;])
</code></pre><p>获取模块：</p>
<pre><code>angular.module(&apos;模块名&apos;)
</code></pre><p>启动多个模块（就是将多个模块组织到一起，然后作用到某个具体的DOM节点上）：</p>
<pre><code>angular.bootstrap(document, [&apos;模块名&apos;[,&apos;模块名&apos;]])
</code></pre><p>多模块启动最佳实践：</p>
<pre><code>angular.module(&apos;app1&apos;, []).controller(&apos;AController&apos;)
angular.module(&apos;app2&apos;, []).controller(&apos;BController&apos;)
angular.module(&apos;app3&apos;, []).controller(&apos;CController&apos;)

angular.module(&apos;mainApp&apos;, [&apos;app1&apos;, &apos;app2&apos;, &apos;app3&apos;])
// 最后在 HTML 中通过 ng-app 加载 mainApp 就可以使用 app1、app2、app3 中的所有控制器成员了
// 代码如下
</code></pre><p>html:</p>
<pre><code>&lt;html&gt;
  &lt;head&gt;&lt;/head&gt;
  &lt;body ng-app=&quot;mainApp&quot;&gt;
    &lt;div ng-controller=&quot;AController&quot;&gt;&lt;/div&gt;
    &lt;div ng-controller=&quot;BController&quot;&gt;&lt;/div&gt;
    &lt;div ng-controller=&quot;CController&quot;&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>如何划分模块：</p>
<ul>
<li>控制器按照页面具体的业务功能来划分</li>
<li>模块就是将处理相关联业务的控制器组织到一起</li>
<li>这样无论是从代码结构组织上还是可维护性上都是一种比较好的实践方式</li>
</ul>
<p>控制器</p>
<p>第一种方式(在新版本中已被废弃)：</p>
<pre><code>function DemoController ($scope) {
  // some code here
}
</code></pre><p>第二种方式(代码混淆压缩之后有问题)：</p>
<pre><code>angular.module(&apos;app&apos;, [])
  .controller(&apos;DemoController&apos;, function () {
    // some code here
  })
</code></pre><p>第三方方式（推荐的方式）：</p>
<pre><code>angular.module(&apos;app&apos;, [])
  .controller(&apos;DemoController&apos;, [&apos;$scope&apos;, function () {
    // some code here
  }])
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AngularJS 表达式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AngularJS 表达式写在双大括号内：&lt;/li&gt;
&lt;li&gt;AngularJS 表达式把数据绑定到 HTML，与 ng-bind 指令基本一致&lt;/li&gt;
&lt;li&gt;AngularJS 将在表达式书写的位置”输出”数据&lt;u
    
    </summary>
    
    
      <category term="angular" scheme="http://yoursite.com/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>angular-路由-详解</title>
    <link href="http://yoursite.com/2015/04/04/angular%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2015/04/04/angular详解/</id>
    <published>2015-04-04T02:26:07.000Z</published>
    <updated>2017-03-24T12:16:59.657Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ngRoute"><a href="#ngRoute" class="headerlink" title="ngRoute"></a>ngRoute</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>一：安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save angular-route</div></pre></td></tr></table></figure>
<p>二：引包</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"angular.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"angular-route.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>三：加载依赖</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">angular.module(<span class="string">'app'</span>, [<span class="string">'ngRoute'</span>])</div></pre></td></tr></table></figure>
<p>四：配置路由</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">angular.module(<span class="string">'app'</span>, [<span class="string">'ngRoute'</span>])</div><div class="line">  .config([<span class="string">'$routeProvider'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">$routeProvider</span>) </span>&#123;</div><div class="line">    $routeProvider</div><div class="line">     .when(<span class="string">'/Book/:bookId'</span>, &#123;</div><div class="line">        <span class="attr">templateUrl</span>: <span class="string">'book.html'</span>,</div><div class="line">        <span class="attr">controller</span>: <span class="string">'BookController'</span>,</div><div class="line">      &#125;)</div><div class="line">      .when(<span class="string">'/Book/:bookId/ch/:chapterId'</span>, &#123;</div><div class="line">        <span class="attr">templateUrl</span>: <span class="string">'chapter.html'</span>,</div><div class="line">        <span class="attr">controller</span>: <span class="string">'ChapterController'</span></div><div class="line">      &#125;);</div><div class="line">  &#125;])</div></pre></td></tr></table></figure>
<p>五：在 HTML 中留坑</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- ng-view 指令就是用来配合路由使用的，路由会将匹配到的路由指定的 HTML 模板渲染到通过 ng-view 留坑的位置 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-view</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="与路由相关的一些配套-API"><a href="#与路由相关的一些配套-API" class="headerlink" title="与路由相关的一些配套 API"></a>与路由相关的一些配套 API</h3><ul>
<li>ngView<ul>
<li>留坑，标记被路由替换处理的位置</li>
</ul>
</li>
<li>$routeProvider<ul>
<li>作用：配置路由表</li>
<li>根据不同的请求路径执行对应的控制器及渲染对应的HTML视图模板</li>
<li>when(path: String, route: Object)<ul>
<li>route<ul>
<li>controller</li>
<li>template</li>
<li>templateUrl</li>
<li>redirectTo</li>
</ul>
</li>
</ul>
</li>
<li>otherwise(params: Object | String)</li>
</ul>
</li>
<li>$route<ul>
<li>$route.reload() 重载当前路由</li>
<li>$route.updateParams(Object) 更新路由中的动态路径参数</li>
</ul>
</li>
<li>$routeParams<ul>
<li>用来获取路由参数</li>
<li>例如：/user/:id 是一个动态路径，则可以在控制器中通过 $routeParams 获取 :id 的值</li>
<li>也可以获取查询字符串中的参数，例如请求路径是 /user?id=1 则通过 $routeParams 也可以获取到</li>
</ul>
</li>
</ul>
<p>### </p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ngRoute&quot;&gt;&lt;a href=&quot;#ngRoute&quot; class=&quot;headerlink&quot; title=&quot;ngRoute&quot;&gt;&lt;/a&gt;ngRoute&lt;/h2&gt;&lt;h3 id=&quot;基本使用&quot;&gt;&lt;a href=&quot;#基本使用&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
    
      <category term="angular" scheme="http://yoursite.com/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>angular 初体验</title>
    <link href="http://yoursite.com/2015/03/15/angular-%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>http://yoursite.com/2015/03/15/angular-初体验/</id>
    <published>2015-03-15T12:16:00.000Z</published>
    <updated>2017-03-24T12:18:27.572Z</updated>
    
    <content type="html"><![CDATA[<p>AngularJS 简介</p>
<p>以下简称：ng</p>
<p>知识储备</p>
<ul>
<li>HTML</li>
<li>CSS</li>
<li>JavaScript</li>
</ul>
<p>为了更好的学习效果，最好擅长一些 JavaScript 库，如果有后台开发经验效果最佳。</p>
<p>哪些人在用</p>
<ul>
<li>前端开发人员</li>
<li>后端开发人员目前更多</li>
</ul>
<p>什么是 AngularJS</p>
<ul>
<li>一款非常优秀的前端高级 JavaScript 框架</li>
<li>2009 年起先由 Miško Hevery 和 Adam Abron 开发</li>
<li>后被 Google 收购，用于其多款产品</li>
<li>有一个全职的开发团队继续开发和维护这个库</li>
<li>可以轻松构建 SPA 应用程序</li>
<li>通过 指令 扩展了 HTML，通过 表达式 绑定数据到 HTML<ul>
<li>angular 就是一个高级的模板引擎</li>
</ul>
</li>
<li>最大程度上解放了 DOM 操作</li>
<li>构建更加动感的 HTML 应用程序</li>
</ul>
<p>AngularJS是为了克服HTML在构建应用上的不足而设计的。</p>
<p>AngularJS有着诸多特性，最为核心的是：</p>
<ul>
<li>MVC</li>
<li>模块化</li>
<li>自动化双向数据绑定</li>
<li>语义化标签、依赖注入等等</li>
</ul>
<p>为什么使用 Angular(演示 Demo 中的 compare)</p>
<p>以前我们是这样的：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;传统页面操作数据操作方式&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;input id=&quot;txt_value&quot; type=&quot;number&quot;&gt;
  &lt;input id=&quot;btn_add&quot; type=&quot;button&quot; value=&quot;增加&quot;&gt;
  &lt;script&gt;
    (function(window, document) {
      var txt = document.querySelector(&apos;#txt_value&apos;);
      var btn = document.querySelector(&apos;#btn_add&apos;);
      btn.addEventListener(&apos;click&apos;, function(e) {
        var now = txt.value - 0;
        now = now + 1;
        txt.value = now;
      });
    })(window, document);
  &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>以后将会是这样的：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;使用AngularJS实现自增功能&lt;/title&gt;
&lt;/head&gt;
&lt;body ng-app&gt;
  &lt;input type=&quot;number&quot; ng-model=&quot;value&quot;&gt;
  &lt;input type=&quot;button&quot; ng-click=&quot;value=value+1&quot; value=&quot;增加&quot;&gt;
  &lt;script src=&quot;../bower_components/angular/angular.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><ul>
<li>更少的代码，实现更强劲的功能，当然不仅仅是这些，这些只是皮毛</li>
<li>背后带来的价值才是巨大的</li>
<li>带领前端进入了 MV* 的时代</li>
<li>又是一场革命，Angular 引领了前端工业革命<ul>
<li>从 Angular 2009 年之后，前端市场越来越火爆了</li>
</ul>
</li>
</ul>
<p>AngularJS 优缺点</p>
<p>优点：</p>
<ol>
<li>AngularJS模板功能强大丰富，自带了极其丰富的angular指令。</li>
<li>AngularJS是完全可扩展的，与其他库的兼容效果很好，每一个功能可以修改或更换，以满足开发者独特的开发流程和功能的需求。</li>
<li>AngularJS是一个比较完善的前端MVC框架，包含服务，模板，数据双向绑定，模块化，路由，过滤器，依赖注入等所有功能；</li>
<li>AngularJS是互联网巨人谷歌开发，这也意味着他有一个坚实的基础和社区支持。</li>
</ol>
<p>缺点：</p>
<ol>
<li>AngularJS强约束导致学习成本较高，对前端不友好。但遵守 AngularJS 的约定时，生产力会很高，对 后台服务器开发程序员友好。</li>
<li>AngularJS不利于SEO，因为所有内容都是动态获取并渲染生成的，搜索引擎没法爬取。</li>
<li>AngularJS作为 MVVM 框架，因为实现了数据的双向绑定，对于大数组、复杂对象会存在性能问题。</li>
</ol>
<p>AngularJS 使用场景</p>
<ul>
<li>单页面应用程序</li>
<li>复杂的后台管理系统<ul>
<li>CRUD（增加 Create、查询 Retrieve、更新 Update、删除 Delete）</li>
<li>繁杂的 DOM 操作处理的页面</li>
</ul>
</li>
</ul>
<p>Angular 是一个类 MVC 类结构的 JavaScript 框架，建议构建 CRUD 类型应用的时候使用它，</p>
<p>而对于那些图形编辑、游戏开发等应用，使用 Angular 就不如调用其它 JavaScript 类库方便，</p>
<p>如 jQuery。</p>
<p>学习资源推荐</p>
<ul>
<li>菜鸟教程：<a href="http://www.runoob.com/angularjs/angularjs-tutorial.html" target="_blank" rel="external">http://www.runoob.com/angularjs/angularjs-tutorial.html</a></li>
<li>AngularJS 中文社区：<a href="http://angularjs.cn/" target="_blank" rel="external">http://angularjs.cn/</a></li>
<li>官方文档：<a href="https://docs.angularjs.org/api" target="_blank" rel="external">https://docs.angularjs.org/api</a></li>
<li>AngularJS 权威教程<ul>
<li>API 解释的更详细</li>
</ul>
</li>
<li>AngularJS 深度剖析与最佳实践<ul>
<li>更注重实践</li>
</ul>
</li>
<li>AngularJS入门教程</li>
<li>七步从Angular.JS菜鸟到专家</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AngularJS 简介&lt;/p&gt;
&lt;p&gt;以下简称：ng&lt;/p&gt;
&lt;p&gt;知识储备&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTML&lt;/li&gt;
&lt;li&gt;CSS&lt;/li&gt;
&lt;li&gt;JavaScript&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了更好的学习效果，最好擅长一些 JavaScript 库，如果
    
    </summary>
    
    
      <category term="angular" scheme="http://yoursite.com/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>字符串的方法</title>
    <link href="http://yoursite.com/2015/03/13/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2015/03/13/字符串的方法/</id>
    <published>2015-03-13T11:34:19.000Z</published>
    <updated>2017-03-13T11:45:39.935Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><p>.charAt(索引);//返回的是该索引对应的字符串;</p>
</li>
<li><p>.charCodeAt(索引);//返回的是是这个索引对应的字符串的ASCII码值;</p>
</li>
<li><p>.concat(字符串1,字符串2…);返回的是拼接后的字符串;</p>
</li>
<li><p>.slice(开始的索引,结束的索引);</p>
</li>
<li><p>.slice(3,8);返回的是从索引为3的位置开始截取的字符串到索引为8的前一个结束(到7，包括7)</p>
</li>
<li><p>.substring(只写一个参数);从这个索引位置开始截取,一直到最后,获取新的字符串;</p>
</li>
<li><p>.substring(索引1,索引2);从索引1开始截取到索引2的前一个;</p>
</li>
<li><p>.substr(索引);返回的是从索引位置开始截取，一直到最后;</p>
</li>
<li><p>.substr(索引,长度);返回的是从索引位置开始截取，截取一定长度,得到新的字符串;</p>
</li>
<li><p>.indexOf(“要查找的字符串”);如果找到了则返回字符串的索引,否则返回-1;</p>
</li>
<li><p>.lastIndexOf(要找的字符串);从字符串的后面向前找,但是索引仍然是从左开始,从0开始,找到则返回对应的索引,找不到则返回-1;</p>
</li>
<li><p>.trim();清除字符串两边的空格;</p>
</li>
<li><p>.toLocaleLowerCase()把字符串转小写;</p>
</li>
<li><p>.toLocaleUpperCase()把字符串转大写;</p>
</li>
<li><p>.replace(“要替换的字符串”,”替换的字符串”);返回新的字符串;</p>
</li>
<li><p>.split(“要干掉的字符串内容”);返回的是字符串组合成的数组;</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;.charAt(索引);//返回的是该索引对应的字符串;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;.charCodeAt(索引);//返回的是是这个索引对应的字符串的ASCII码值;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;.concat(字符串1,字符串2…);返回
    
    </summary>
    
    
      <category term="string" scheme="http://yoursite.com/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>如何搭建自己的静态博客</title>
    <link href="http://yoursite.com/2015/01/24/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2015/01/24/如何搭建自己的静态博客/</id>
    <published>2015-01-24T12:30:38.000Z</published>
    <updated>2017-03-24T12:33:00.931Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Hexo 静态博客生成器搭建自己的个人博客</p>
<p>官方网站：<a href="https://hexo.io/zh-cn/" target="_blank" rel="external">https://hexo.io/zh-cn/</a></p>
<pre><code># 全局安装 hexo
npm install -g hexo-cli

# 初始化一个博客
hexo init blog

# 切入 blog 目录
cd blog

# 启动预览
hexo server

# 创建博客
hexo new 文章标题
</code></pre><p>结合 Github Pages 自动发布博客</p>
<p>一：Github 创建域名仓库</p>
<p>二：修改博客中的 _config.yml 文件中</p>
<pre><code>deploy:
  type: git
  repo: https://hhh:abc123456@github.com/hh/hh.github.io.git
</code></pre><p>三：安装插件</p>
<pre><code>npm install hexo-deployer-git --save
</code></pre><p>四：发布</p>
<pre><code>hexo generate --deploy
hexo deploy --generate
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 Hexo 静态博客生成器搭建自己的个人博客&lt;/p&gt;
&lt;p&gt;官方网站：&lt;a href=&quot;https://hexo.io/zh-cn/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://hexo.io/zh-cn/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
    
    </summary>
    
    
      <category term="实用" scheme="http://yoursite.com/tags/%E5%AE%9E%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2015/01/04/hello-world/"/>
    <id>http://yoursite.com/2015/01/04/hello-world/</id>
    <published>2015-01-04T02:26:07.000Z</published>
    <updated>2017-03-24T12:11:33.949Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
      <category term="base" scheme="http://yoursite.com/tags/base/"/>
    
  </entry>
  
</feed>
